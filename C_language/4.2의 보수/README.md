# signed vs unsigned

|signed char|unsigned char|
|:---:|:---:|
|부호비트(1)+정수비트(7)|정수비트(8)|
|-127 ~ 128|0 ~ 255|

signed 체계에서는 최상위 비트가 0일때 양수, 1일때 음수로 표현된다.

# 오버플로우

```.c
char c = 127;
c++;
printf("%d\n", c);
// -128
```

char 자료형은 -128 ~ 127 사이의 수를 표현할 수 있다.

char 는 1byte = 8bits 이므로 127은 `01111111` 로 표현된다.

unsigned 였다면 1을 더한 `10000000` 은 128이 되었을텐데

signed 에서는 첫째자리 비트가 부호비트로 사용되어 -128이 되버린다.

이를 overflow 라고 하며 오버플로우가 일어나지 않도록 크기를 신경써주어야 한다.

# 2의 보수

정해진 비트 내에서 양수, 음수를 모두 나타내기 위해 도입된 개념이다.

2의 보수를 이용하면 `x - x = 0` 을 만족하는 `x`의 역수 `-x`를 쉽게 찾을 수 있다.

이진수 `00001010` 을 예로 들어보겠다. (십진수로는 `10`)

1. 먼저 모든 비트를 반전시킨다.

    `11110101`
    
2. 1을 더한다.

    `11110110`

3. 원래의 수와 더하여 0이 되는지 증명한다.
```
    00001010
  + 11110110
 ------------ 
    00000000 (범위를 초과한 수는 버린다)
```

따라서 `11110110` 은 `-10` 인 것을 알 수 있다.

### 왜 쓸까?

1. 이제 음수나 양수의 연산 시에 부호를 고려하지 않고 연산할 수 있다.
2. 맨 앞 비트를 통해 부호를 알 수 있다.

#### 재미있는 점

    맨위에서 10000000 은 -128이라고 했다.
    이것을 2의 보수 방식을 통해 반전시키면
      1. 01111111
      2. 10000000
    이 되면서 원래대로 돌아온다.
    자료형의 범위에서 음수가 한개 더 많은 이유가 여기서 나온다.
