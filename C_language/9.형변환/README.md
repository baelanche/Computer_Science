# Casting

```.c
#include <stdio.h>
int main() {
  int a;
  float b = 1.1;
  
  a = b;
  printf("%d", a);
}
```

int형 변수에 float를 대입하고 출력하면 어떻게 될까?

```.bash
1
```

소수점이 짤린채로 컴파일은 완료되지만 경고를 발생시켰다.  
%f 로 출력하지 않아서 소수점이 짤린게 분명하다.


printf("%f", a); 로 고쳐주었다.

```.bash
0.00000
```

더 괴상한 수가 나온다.

이는 변수 타입별로 메모리 상에 다르게 저장되기 때문이다.

<br/><br/>

## 부동소수점

실수타입은 부동소수점 방식을 사용하여 메모리에 값을 저장한다.  
부동이란 떠다닌다는 뜻인데 float 가 여기서 유래되었다.  
실수를 저장하는 다른 방법으로 고정소수점이 있으나 더 넓은 범위의 수를 표현할 수 있는 부동소수점 방식을 절대 다수의 컴퓨터에서 사용한다.

자료형 중 float는 부호에 1비트, 지수부에 8비트, 가수부에 23비트를 사용한다.  
이를 고정소수점 방식으로 구현했다면 2<sup>8</sup>보다 큰 수는 표현할 수 없을 것이다.  
반대로 부동소수점에서는 정규화라는 방식을 취하는데, 식은 아래와 같다.

(1.가수부) x 2<sup>지수부-127</sup>

한번에 와닿는 식은 아닌 것 같다.  
예를 들어 1111101011.101 이런 수가 있다면 1.111101011101 × 2<sup>9</sup> 이렇게 나타내어 32비트 내로 구현할 수 있다는 것이다.

자세히 알아보자.

* <b>2진법 소수 -> 10진법 소수</b>

10010.1111<sub>(2)</sub> = 2<sup>4</sup> + 2<sup>1</sup> + 2<sup>-1</sup> + 2<sup>-2</sup> + 2<sup>-3</sup> + 2<sup>-4</sup>

2진법으로 표현된 모든 소수는 10진법으로 변환이 가능하다.

* <b>10진법 소수 -> 2진법 소수</b>

-118.625 = -1110110<sub>(2)</sub> - 2<sup>-1</sup> - 2<sup>-3</sup> = -1110110.101<sub>(2)</sub>
  
잘 바뀐다.  
하지만 0.5, 0.25, 0.125 와 같은 수 말고 0.1, 0.01 도 바꿀 수 있을까?
